
/*
    Copyright 2010 University of Twente and Delft University of Technology
 
       This file is part of the Mapping libraries and tools, developed
  for research, education and projects in photogrammetry and laser scanning.

  The Mapping libraries and tools are free software: you can redistribute it
    and/or modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation, either version 3 of the License,
                   or (at your option) any later version.

 The Mapping libraries and tools are distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                GNU General Public License for more details.

      You should have received a copy of the GNU General Public License
          along with the Mapping libraries and tools.  If not, see
                      <http://www.gnu.org/licenses/>.

----------------------------------------------------------------------------*/



//---------------------------------------------------------------------------
//GeometricFittingLMQ.cpp
//
//Contains geometric fitting routines using Levenberg Marquardt method. The
//fitting engine is called from Numerical Recipes. As Numerical recipes version
//provides only for single argument passing scheme, the indices are passed to main
//routine, while data is accessed through a global pointer that is set at the start
//of particular function.
//
//Most of the fitting routines use orthogonal distance from the measured points
//to estimated geometry as a figure of merit. To stabilize the solution in most
//functions the direction-vector is normalized, in each call. The other implementation
//details are explained in individual function headers.
//
//The partial derivatives are calculated in most cases using MatLab's ccode() function.
//
//
// Author: Tahir Rabbani Shah
// Date: August 18, 2002 (Delft)
//
//---------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <memory.h>
#define NRANSI
//#include "NumericalRecipes.h"
//#include "NRUtilities.h"
#include "GeometricFittingLMQ.h"
#include "Constants.h"
#include <Vector3D.h>
#include <iostream.h>
using namespace std;

static double **ppGlobalData;
static int nGlobalDimension;
static int nGlobalNumberOfPoints;

static double weightMultiplier = 3;
static double weightStart = 1e10;
static double weight = 1;

/******************************************************************************/
//			Torus Fitting
/******************************************************************************/
//MatLab code for generating partial derivatives.
/*
syms a1 a2 a3 xo1 xo2 xo3 xi1 xi2 xi3 R r real

A = [a1 a2 a3]
Xi = [xi1 xi2 xi3]
Xo = [xo1 xo2 xo3]
a = 1/sqrt(dot(A,A))*A;
Xv = Xi - Xo;

F = cross(a,Xi-Xo)
F = sqrt(dot(F,F))
P = dot(a,Xv);
T = sqrt((R - F)^2 + P^2)-r;

dFdx01=ccode(simple(diff(T,xo1)))
dFdx02=ccode(simple(diff(T,xo2)))
dFdx03=ccode(simple(diff(T,xo3)))

dFda01=ccode(simple(diff(T,a1)))
dFda02=ccode(simple(diff(T,a2)))
dFda03=ccode(simple(diff(T,a3)))

dFdr=ccode(simple(diff(T,r)))
dFdR=ccode(simple(diff(T,R)))
Func = ccode(T)

//C-code generated by MatLab
double dx3 = xi3-xo3;
double dx2 = xi2-xo2;
double dx1 = xi1-xo1;

dFdx01 =

      s1 = 1.0/2.0;      
      s3 = 1/(sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0)));      
      s6 = -R+sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0));      
      s7 = 1/(sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)))*(-2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a3+2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1))/sqrt(a1*a1+a2*a2+a3*a3)*a2);      
      s5 = s6*s7;      
      s6 = -2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a1;      
      s4 = s5+s6;      
      s2 = s3*s4;      
      t0 = s1*s2;


dFdx02 =

      s1 = 1.0/2.0;      
      s3 = 1/(sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0)));      
      s6 = -R+sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0));      
      s7 = 1/(sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)))*(2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2))/sqrt(a1*a1+a2*a2+a3*a3)*a3-2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1))/sqrt(a1*a1+a2*a2+a3*a3)*a1);      
      s5 = s6*s7;      
      s6 = -2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a2;      
      s4 = s5+s6;      
      s2 = s3*s4;      
      t0 = s1*s2;


dFdx03 =

      s1 = 1.0/2.0;      
      s3 = 1/(sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0)));      
      s6 = -R+sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0));      
      s7 = 1/(sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)))*(-2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2))/sqrt(a1*a1+a2*a2+a3*a3)*a2+2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a1);      
      s5 = s6*s7;      
      s6 = -2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a3;      
      s4 = s5+s6;      
      s2 = s3*s4;      
      t0 = s1*s2;


dFda01 =

      s1 = R*(-a2*a1*xo2-a3*a3*xi1-xi1*a2*a2+a2*a1*xi2-a3*a1*xo3+xo1*a2*a2+a3*a3*xo1+a3*a1*xi3)*(-a1*xi1+a1*xo1-a2*xi2+a2*xo2+a3*xo3-a3*xi3);      
      s3 = 1/(sqrt(xi1*xi1+xo1*xo1-2.0*xi3*xo3-2.0*xi1*xo1+xi3*xi3+xo3*xo3+xi2*xi2+xo2*xo2-2.0*xi2*xo2+R*R-2.0*R*sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))));      
      s4 = 1/sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      
      s2 = s3*s4;      
      t0 = s1*s2;


dFda02 =

      s1 = -R*(-a1*a1*xo2+a1*a1*xi2+a2*a1*xo1-xo2*a3*a3-a3*a2*xi3+xi2*a3*a3+a3*a2*xo3-a2*a1*xi1);      
      s4 = -a1*xi1+a1*xo1+a2*xo2-a2*xi2-a3*xi3+a3*xo3;      
      s5 = 1/(sqrt(xi1*xi1+xo1*xo1-2.0*xi3*xo3-2.0*xi1*xo1+xi3*xi3+xo3*xo3+xi2*xi2+xo2*xo2-2.0*xi2*xo2+R*R-2.0*R*sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))));      
      s3 = s4*s5;      
      s4 = 1/sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      
      s2 = s3*s4;      
      t0 = s1*s2;


dFda03 =

      s1 = R*(-a3*a2*xo2-xi3*a2*a2-xi3*a1*a1+xo3*a2*a2+xo3*a1*a1+a3*a2*xi2+a1*a3*xi1-a1*a3*xo1)*(-a1*xi1+a1*xo1-a2*xi2+a2*xo2-a3*xi3+a3*xo3);      
      s3 = 1/(sqrt(xi1*xi1+xo1*xo1-2.0*xi3*xo3-2.0*xi1*xo1+xi3*xi3+xo3*xo3+xi2*xi2+xo2*xo2-2.0*xi2*xo2+R*R-2.0*R*sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))));      
      s4 = 1/sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      
      s2 = s3*s4;      
      t0 = s1*s2;


dFdr =

      t0 = -1.0;


dFdR =

      s1 = 1.0/2.0;      
      s3 = 1/(sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0)));      
      s4 = 2.0*R-2.0*sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0));      
      s2 = s3*s4;      
      t0 = s1*s2;


Func =

      t0 = sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0))-r;

*/
static void TorusFittingCallback(
				double dX,
				double pParameterVector[],
				double* pFunctionValue,
				double pDerivativeVector[],
				int nVectorSize)
{
	double a1,a2,a3;
	double xi1,xi2,xi3;
	double xo1,xo2,xo3;
	double r,R;
	double s1,s2,s3,s4,s5,s6,s7,s8,s9,t0;
	int i=0;
    int nIndex = dX;
    double dMagnitude;

    //Note that only in the update corresponding to first index we need to normalize.
    if(nIndex == 1)
    {
		//Normalize the direction vector. Otherwise may cause numerical instability.
		dMagnitude = sqrt(pParameterVector[1]*pParameterVector[1]+pParameterVector[2]*pParameterVector[2]+pParameterVector[3]*pParameterVector[3]);
		
		pParameterVector[1]=pParameterVector[1]/dMagnitude;
		pParameterVector[2]=pParameterVector[2]/dMagnitude;
		pParameterVector[3]=pParameterVector[3]/dMagnitude;
    }
	
	//update local variables.
	a1 = pParameterVector[1];
    a2 = pParameterVector[2];
    a3 = pParameterVector[3];
  
    xo1 = pParameterVector[4];
    xo2 = pParameterVector[5];
    xo3 = pParameterVector[6];
    R = pParameterVector[7];
    r = pParameterVector[8];
    xi1 = ::ppGlobalData[nIndex][1];
    xi2 = ::ppGlobalData[nIndex][2];
    xi3 = ::ppGlobalData[nIndex][3];
    
    double dx3 = xi3-xo3;
	double dx2 = xi2-xo2;
	double dx1 = xi1-xo1;
    
    double w6 = (-a1*xi1+a1*xo1-a2*xi2+a2*xo2+a3*xo3-a3*xi3);
    double w5 = 1/(sqrt(xi1*xi1+xo1*xo1-2.0*xi3*xo3-2.0*xi1*xo1+xi3*xi3+xo3*xo3+xi2*xi2+xo2*xo2-2.0*xi2*xo2+R*R-2.0*R*sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2))));
    double w4 = 1/sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2));
    double w3 = sqrt(pow(a2*(dx3)-a3*(dx2),2.0)+pow(a3*(dx1)-a1*(dx3),2.0)+pow(a1*(dx2)-a2*(dx1),2.0));
    double w2 = -R+w3;
    double w1 = 1/(sqrt(pow(R-w3,2.0)+pow(a1*(dx1)+a2*(dx2)+a3*(dx3),2.0)));

	//C-code generated by MatLab
	//dFdx01 = pDerivativeVector[4]
	s3 = w1;      
	s6 = w2;      
	s7 = 1/(w3)*(-2.0*(a3*(dx1)-a1*(dx3))/a3+2.0*(a1*(dx2)-a2*(dx1))*a2);      
	s5 = s6*s7;      
	s6 = -2.0*(a1*(dx1)+a2*(dx2)+a3*(dx3))*a1;      
	s4 = s5+s6;      
	s2 = s3*s4;      
	pDerivativeVector[4] = 0.5*s2;

	//dFdx02 = pDerivativeVector[5]
	s3 = w1;      
	s6 = w2;      
	s7 = 1/(w3)*(2.0*(a2*(dx3)-a3*(dx2))*a3-2.0*(a1*(dx2)-a2*(dx1))*a1);      
	s5 = s6*s7;      
	s6 = -2.0*(a1*(dx1)+a2*(dx2)+a3*(dx3))*a2;      
	s4 = s5+s6;      
	s2 = s3*s4;      
	pDerivativeVector[5] = 0.5*s2;

	//dFdx03 = pDerivativeVector[6]
	s3 = w1;      
	s6 = w2;      
	s7 = 1/(w3)*(-2.0*(a2*(dx3)-a3*(dx2))*a2+2.0*(a3*(dx1)-a1*(dx3))*a1);      
	s5 = s6*s7;      
	s6 = -2.0*(a1*(dx1)+a2*(dx2)+a3*(dx3))*a3;      
	s4 = s5+s6;      
	s2 = s3*s4;      
	pDerivativeVector[6] = 0.5*s2;

	//dFda01 = pDerivativeVector[1]
	s1 = R*(-a2*a1*xo2-a3*a3*xi1-xi1*a2*a2+a2*a1*xi2-a3*a1*xo3+xo1*a2*a2+a3*a3*xo1+a3*a1*xi3)*w6;      
	s3 = w5;      
	s4 = w4;      
	s2 = s3*s4;      
	pDerivativeVector[1] = s1*s2;

	//dFda02 = pDerivativeVector[2]
	s1 = -R*(-a1*a1*xo2+a1*a1*xi2+a2*a1*xo1-xo2*a3*a3-a3*a2*xi3+xi2*a3*a3+a3*a2*xo3-a2*a1*xi1);      
	s4 = w6;      
	s5 = w5;      
	s3 = s4*s5;      
	s4 = w4;      
	s2 = s3*s4;      
	pDerivativeVector[2] = s1*s2;

	//dFda03 = pDerivativeVector[3]
	s1 = R*(-a3*a2*xo2-xi3*a2*a2-xi3*a1*a1+xo3*a2*a2+xo3*a1*a1+a3*a2*xi2+a1*a3*xi1-a1*a3*xo1)*w6;      
	s3 = w5;      
	s4 = w4;      
	s2 = s3*s4;      
	pDerivativeVector[3] = s1*s2;
	
	//dFdR = pDerivativeVector[7]
	s3 = w1;      
	s4 = 2.0*R-2.0*w3;      
	s2 = s3*s4;      
	pDerivativeVector[7] = 0.5*s2;

	//dFdr = pDerivativeVector[8] 
	pDerivativeVector[8] = -1.0;

	//Func =
	*pFunctionValue = sqrt(pow(R-w3,2.0)+pow(a1*(dx1)+a2*(dx2)+a3*(dx3),2.0))-r;
	 
		
}
		
static void TorusFittingCallbackOld(
				double dX,
				double pParameterVector[],
				double* pFunctionValue,
				double pDerivativeVector[],
				int nVectorSize)
{
	double a1,a2,a3;
	double xi1,xi2,xi3;
	double xo1,xo2,xo3;
	double r,R;
	double s1,s2,s3,s4,s5,s6,s7,s8,s9,t0;
	int i=0;
    int nIndex = dX;
    double dMagnitude;

    //Note that only in the update corresponding to first index we need to normalize.
    if(nIndex==1 || 1==1)
    {
		//Normalize the direction vector. Otherwise may cause numerical instability.
		dMagnitude = sqrt(pParameterVector[1]*pParameterVector[1]+pParameterVector[2]*pParameterVector[2]+pParameterVector[3]*pParameterVector[3]);
		
		pParameterVector[1]=pParameterVector[1]/dMagnitude;
		pParameterVector[2]=pParameterVector[2]/dMagnitude;
		pParameterVector[3]=pParameterVector[3]/dMagnitude;
    }
	
	//update local variables.
	a1 = pParameterVector[1];
    a2 = pParameterVector[2];
    a3 = pParameterVector[3];
  
    xo1 = pParameterVector[4];
    xo2 = pParameterVector[5];
    xo3 = pParameterVector[6];
    R = pParameterVector[7];
    r = pParameterVector[8];
    xi1 = ::ppGlobalData[nIndex][1];
    xi2 = ::ppGlobalData[nIndex][2];
    xi3 = ::ppGlobalData[nIndex][3];
    
    double dx3 = xi3-xo3;
	double dx2 = xi2-xo2;
	double dx1 = xi1-xo1;
    
	//C-code generated by MatLab
	
	//dFdx01 = pDerivativeVector[4]
	s1 = 1.0/2.0;      
	s3 = 1/(sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0)));      
	s6 = -R+sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0));      
	s7 = 1/(sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)))*(-2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a3+2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1))/sqrt(a1*a1+a2*a2+a3*a3)*a2);      
	s5 = s6*s7;      
	s6 = -2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a1;      
	s4 = s5+s6;      
	s2 = s3*s4;      
	pDerivativeVector[4] = t0 = s1*s2;


	//dFdx02 = pDerivativeVector[5]

	s1 = 1.0/2.0;      
	s3 = 1/(sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0)));      
	s6 = -R+sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0));      
	s7 = 1/(sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)))*(2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2))/sqrt(a1*a1+a2*a2+a3*a3)*a3-2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1))/sqrt(a1*a1+a2*a2+a3*a3)*a1);      
	s5 = s6*s7;      
	s6 = -2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a2;      
	s4 = s5+s6;      
	s2 = s3*s4;      
	pDerivativeVector[5] = t0 = s1*s2;


	//dFdx03 = pDerivativeVector[6]

	s1 = 1.0/2.0;      
	s3 = 1/(sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0)));      
	s6 = -R+sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0));      
	s7 = 1/(sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)))*(-2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2))/sqrt(a1*a1+a2*a2+a3*a3)*a2+2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a1);      
	s5 = s6*s7;      
	s6 = -2.0*(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3))/sqrt(a1*a1+a2*a2+a3*a3)*a3;      
	s4 = s5+s6;      
	s2 = s3*s4;      
	pDerivativeVector[6] = t0 = s1*s2;


	//dFda01 = pDerivativeVector[1]

	s1 = R*(-a2*a1*xo2-a3*a3*xi1-xi1*a2*a2+a2*a1*xi2-a3*a1*xo3+xo1*a2*a2+a3*a3*xo1+a3*a1*xi3)*(-a1*xi1+a1*xo1-a2*xi2+a2*xo2+a3*xo3-a3*xi3);      
	s3 = 1/(sqrt(xi1*xi1+xo1*xo1-2.0*xi3*xo3-2.0*xi1*xo1+xi3*xi3+xo3*xo3+xi2*xi2+xo2*xo2-2.0*xi2*xo2+R*R-2.0*R*sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))));      
	s4 = 1/sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      
	s2 = s3*s4;      
	pDerivativeVector[1] = t0 = s1*s2;


	//dFda02 = pDerivativeVector[2]

	s1 = -R*(-a1*a1*xo2+a1*a1*xi2+a2*a1*xo1-xo2*a3*a3-a3*a2*xi3+xi2*a3*a3+a3*a2*xo3-a2*a1*xi1);      
	s4 = -a1*xi1+a1*xo1+a2*xo2-a2*xi2-a3*xi3+a3*xo3;      
	s5 = 1/(sqrt(xi1*xi1+xo1*xo1-2.0*xi3*xo3-2.0*xi1*xo1+xi3*xi3+xo3*xo3+xi2*xi2+xo2*xo2-2.0*xi2*xo2+R*R-2.0*R*sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))));      
	s3 = s4*s5;      
	s4 = 1/sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      
	s2 = s3*s4;      
	pDerivativeVector[2] = t0 = s1*s2;


	//dFda03 = pDerivativeVector[3]

	s1 = R*(-a3*a2*xo2-xi3*a2*a2-xi3*a1*a1+xo3*a2*a2+xo3*a1*a1+a3*a2*xi2+a1*a3*xi1-a1*a3*xo1)*(-a1*xi1+a1*xo1-a2*xi2+a2*xo2-a3*xi3+a3*xo3);      
	s3 = 1/(sqrt(xi1*xi1+xo1*xo1-2.0*xi3*xo3-2.0*xi1*xo1+xi3*xi3+xo3*xo3+xi2*xi2+xo2*xo2-2.0*xi2*xo2+R*R-2.0*R*sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))));      
	s4 = 1/sqrt((2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a2*xo3*a3*xo2-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3-2.0*a3*xi1*a1*xi3-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1+a3*a3*xo1*xo1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a1*a1*xo2*xo2+a2*a2*xi1*xi1+a2*a2*xo1*xo1-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi3*xo3-2.0*a1*a1*xi2*xo2-2.0*a2*a2*xi1*xo1+a3*a3*xi1*xi1-2.0*a3*a3*xi1*xo1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      
	s2 = s3*s4;      
	pDerivativeVector[3] = t0 = s1*s2;
	
	//dFdR = pDerivativeVector[7]
	s1 = 1.0/2.0;      
	s3 = 1/(sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0)));      
	s4 = 2.0*R-2.0*sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0));      
	s2 = s3*s4;      
	pDerivativeVector[7] = t0 = s1*s2;


	//dFdr = pDerivativeVector[8] 
	pDerivativeVector[8] = t0 = -1.0;

	//Func =
	t0 = sqrt(pow(R-sqrt(pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx3)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx2),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx1)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx3),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx2)-1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx1),2.0)),2.0)+pow(1/(sqrt(a1*a1+a2*a2+a3*a3))*a1*(dx1)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a2*(dx2)+1/(sqrt(a1*a1+a2*a2+a3*a3))*a3*(dx3),2.0))-r;
	*pFunctionValue = t0;
		
}	

//Fits a Torus to give XYZ coordinates in ppData.
//The number of parmeters is 8
// (P1,P2,P3) define a unit vector giving the axial direction of torus.
// (P4,P5,P6) give the centre point of torus.
// (P7) is the major radius.
// (P8) is the minor radius.
//
// ppData:				input X,Y,Z matrix.
// nRows:				Number of rows
// nCols: 				Number of columns, must be atleast 3.
// pStdVector:			Standard deviation of each measurement.
// pConstraintVector:   Must be at least 8x1. If 0 keep that param fixed.
// pParameterVector:	Seed values, must be 8x1.
// pChiSquare:			Has final chisquare on return.
// pMaxIteration:		Has allowed max iterations on entry, and has final iteration count
//	
int FitTorusLMQ(double** ppData,
					int nRows,
                    int nCols,
                    double* pStdVector,
                    int* pConstraintVector,
                    double* pParameterVector,
                    double* pChiSquare,
                    int* pMaxIterations)
{
    const int nNumberOfParams = 8;
    return
    FitLMQ(ppData,
   			nRows,
			nCols,
			pStdVector,
			pConstraintVector,
			pParameterVector,
			pChiSquare,
			pMaxIterations,
			nNumberOfParams,
			TorusFittingCallback);


}
static 
void SphereFittingCallback(
				double dX,
				double pParameterVector[],
				double* pFunctionValue,
				double pDerivativeVector[],
				int nVectorSize)
{
	double xi1,xi2,xi3;
	double dMagnitude;
	double dFactor = 1;
	int nIndex = dX;
	
	xi1 = ::ppGlobalData[nIndex][1] - pParameterVector[1];
    xi2 = ::ppGlobalData[nIndex][2] - pParameterVector[2];
    xi3 = ::ppGlobalData[nIndex][3] - pParameterVector[3];
    dMagnitude = sqrt(xi1*xi1+xi2*xi2+xi3*xi3);
    if(dMagnitude>0)
    	dFactor = 1/dMagnitude;
    
    pDerivativeVector[1] = -xi1*dFactor;
    pDerivativeVector[2] = -xi2*dFactor;
    pDerivativeVector[3] = -xi3*dFactor;
    pDerivativeVector[4] = -1;

	//Func =
	*pFunctionValue = dMagnitude - pParameterVector[4];
	 
		
}

//Fits a Sphere to give XYZ coordinates in ppData.
//The number of parmeters is 4
// (P1,P2,P3) define the centre of sphere.
// (P4) is the radius.
//
// ppData:				input X,Y,Z matrix.
// nRows:				Number of rows
// nCols: 				Number of columns, must be atleast 3.
// pStdVector:			Standard deviation of each measurement.
// pConstraintVector:   Must be at least 4x1. If 0 keep that param fixed.
// pParameterVector:	Seed values, must be 4x1.
// pChiSquare:			Has final chisquare on return.
// pMaxIteration:		Has allowed max iterations on entry, and has final iteration count
//	
int FitSphereLMQ(double** ppData,
					int nRows,
                    int nCols,
                    double* pStdVector,
                    int* pConstraintVector,
                    double* pParameterVector,
                    double* pChiSquare,
                    int* pMaxIterations)
{
    const int nNumberOfParams = 4;
    return
    FitLMQ(ppData,
   			nRows,
			nCols,
			pStdVector,
			pConstraintVector,
			pParameterVector,
			pChiSquare,
			pMaxIterations,
			nNumberOfParams,
			SphereFittingCallback);


}
		

//Main Levenberg-Marquardt fitting routine.
// ppData: 				Matrix containing data. It is assumed the LMQ callback knows what to do with this
//						data once it knows the index of row to access.
// nRows:				Number of rows of ppData
// nCols:				Number of columns of ppData.
// pStdVector:			Standard deviation vector. size = nRows
// pConstraintVector:	If 1 parameter is fitted, for 0 it is fixed. size = nParameterVectorSize
// pChiSquare			Contains chisquare error on return.
// pMaxIterations:		Passes maximum iterations on entry, has actual iterations on exit.
// nNumberOfParams		Number of parameters in function to be fitted.
// pFittingCallback		Fitting callback function. Must update function value and its partial derivatives
//						for a given index in dX.

int FitLMQ(double** ppData,
				int nRows,
               	int nCols,
              	double* pStdVector,
             	int* pConstraintVector,
                double* pParameterVector,
                double* pChiSquare,
                int* pMaxIterations,
				int nNumberOfParams,
				LMQCallback pFittingCallback,
				const bool showDebugMessages)
{
    double* pXVector, *pYVector, **ppCovarianceMatrix, **ppAlphaMatrix;
    double dLamda;
    double dCurrentChiSquare,dOldChiSquare;
    int i,j,k, nIterationCounter, nFutileIterations;
	//Do error checking on inputs.

	//Allocate memory for local usage.
    pXVector=(double*)dvector(1,nRows);
    pYVector= (double*)dvector(1,nRows);
    ppCovarianceMatrix=(double**)matrix(1,nNumberOfParams,1,nNumberOfParams);
    ppAlphaMatrix=(double**)matrix(1,nNumberOfParams,1,nNumberOfParams);

    //Assign global variables for data passing.
    ::ppGlobalData=ppData;
	::nGlobalDimension=nCols;
	::nGlobalNumberOfPoints=nRows;

    //Initialize local arrays.
    for(i=1;i<=nRows;i++)
    {
    	pXVector[i]=i;
        pYVector[i]=0;
    }
    
    //First call of mrqmin() is for initialization.
   	dLamda = -1;
    mrqmin(pXVector,
    	pYVector,
        pStdVector,
        nRows,
        pParameterVector,
        pConstraintVector,
        nNumberOfParams,
        ppCovarianceMatrix,
        ppAlphaMatrix,
        &dCurrentChiSquare,
        pFittingCallback,
        &dLamda);
	
	//Start calling mrqmin in an infinite loop. Exiting if no change, or number of iterations exceeded.
    nIterationCounter = 0;
    nFutileIterations = 0;
    for(;;)
    {
        //Output the parmeter values for debugging.
		if(showDebugMessages)
		{
			for (i=1;i<=nNumberOfParams;i++)
				printf("Parameter %d: %11.8lf\n",i,pParameterVector[i]);
		}
        //next iteration.
        nIterationCounter++;
        dOldChiSquare = dCurrentChiSquare;
		
		
		mrqmin(pXVector,
            pYVector,
            pStdVector,
            nRows,
            pParameterVector,
            pConstraintVector,
            nNumberOfParams,
            ppCovarianceMatrix,
            ppAlphaMatrix,
            &dCurrentChiSquare,
            pFittingCallback,
            &dLamda);
		
		if(showDebugMessages)
		{	    
	    	printf("\nIteration %d: ChiSquare: %8.5lf   lamda:%11.7lf\n",nIterationCounter,dCurrentChiSquare,dLamda);
		}

        //Keep track of futile iterations.
        if(dOldChiSquare>dCurrentChiSquare)
        {
            nFutileIterations=0;
        }
        else if(fabs(dOldChiSquare-dCurrentChiSquare)<1e-2)
        {
            nFutileIterations++;
        }

        //break out of loop if no improvement or iteration count overflow.
        if(nFutileIterations>30 || nIterationCounter>*pMaxIterations)
            break;
    }
    
    //The final iteration with dLamda = 0 is necessary to free memory internally allocated.
    //Also it updates the covariance matrix.
    dLamda = 0;
    mrqmin(pXVector,
            pYVector,
            pStdVector,
            nRows,
            pParameterVector,
            pConstraintVector,
            nNumberOfParams,
            ppCovarianceMatrix,
            ppAlphaMatrix,
            &dCurrentChiSquare,
            pFittingCallback,
            &dLamda);


    //Copy the results.
    *pChiSquare = dCurrentChiSquare;
	*pMaxIterations = nIterationCounter;

    //Reset the global pointers so that no harms is done accidently.
    ::ppGlobalData=NULL;
	::nGlobalDimension=-1;
	::nGlobalNumberOfPoints=-1;

    //Free the allocate resources.
    free_dvector(pXVector,1,nRows);
    free_dvector(pYVector,1,nRows);
    free_matrix(ppCovarianceMatrix,1,nNumberOfParams,1,nNumberOfParams);
    free_matrix(ppAlphaMatrix,1,nNumberOfParams,1,nNumberOfParams);

    //return with function status.
    return 1;
}

int FitLMQConstrained(double** ppData,
				int nRows,
               	int nCols,
              	double* pStdVector,
             	int* pConstraintVector,
                double* pParameterVector,
                double* pChiSquare,
                int* pMaxIterations,
				int nNumberOfParams,
				LMQCallback pFittingCallback,
				const bool showDebugMessages)
{
    double* pXVector, *pYVector, **ppCovarianceMatrix, **ppAlphaMatrix;
    double dLamda;
    double dCurrentChiSquare,dOldChiSquare;
    int i,j,k, nIterationCounter, nFutileIterations;
	//Do error checking on inputs.

	//Allocate memory for local usage.
    pXVector=(double*)dvector(1,nRows);
    pYVector= (double*)dvector(1,nRows);
    ppCovarianceMatrix=(double**)matrix(1,nNumberOfParams,1,nNumberOfParams);
    ppAlphaMatrix=(double**)matrix(1,nNumberOfParams,1,nNumberOfParams);

    //Assign global variables for data passing.
    ::ppGlobalData=ppData;
	::nGlobalDimension=nCols;
	::nGlobalNumberOfPoints=nRows;

    //Initialize local arrays.
    for(i=1;i<=nRows;i++)
    {
    	pXVector[i]=i;
        pYVector[i]=0;
    }
    
    //First call of mrqmin() is for initialization.
   	dLamda = -1;
    mrqmin(pXVector,
    	pYVector,
        pStdVector,
        nRows,
        pParameterVector,
        pConstraintVector,
        nNumberOfParams,
        ppCovarianceMatrix,
        ppAlphaMatrix,
        &dCurrentChiSquare,
        pFittingCallback,
        &dLamda);
	
	//Start calling mrqmin in an infinite loop. Exiting if no change, or number of iterations exceeded.
    nIterationCounter = 0;
    nFutileIterations = 0;
    for(;;)
    {
        //Output the parmeter values for debugging.
		if(showDebugMessages)
		{
			for (i=1;i<=nNumberOfParams;i++)
				printf("Parameter %d: %11.8lf\n",i,pParameterVector[i]);
		}
        //next iteration.
        nIterationCounter++;
        dOldChiSquare = dCurrentChiSquare;
		
		
		mrqmin(pXVector,
            pYVector,
            pStdVector,
            nRows,
            pParameterVector,
            pConstraintVector,
            nNumberOfParams,
            ppCovarianceMatrix,
            ppAlphaMatrix,
            &dCurrentChiSquare,
            pFittingCallback,
            &dLamda);
		
		if(1)//showDebugMessages)
		{	    
	    	printf("\nIteration %d: ChiSquare: %8.5lf   lamda:%11.7lf\n",nIterationCounter,dCurrentChiSquare,dLamda);
		}

        //Keep track of futile iterations.
        if(dOldChiSquare>dCurrentChiSquare)
        {
            nFutileIterations=0;
		}
        else if(fabs(dOldChiSquare-dCurrentChiSquare)<1e-6)
        {
            nFutileIterations++;
        }

        //break out of loop if no improvement or iteration count overflow.
        if(nFutileIterations>30 || nIterationCounter>*pMaxIterations)
            break;
    }
    
    //The final iteration with dLamda = 0 is necessary to free memory internally allocated.
    //Also it updates the covariance matrix.
    dLamda = 0;
    mrqmin(pXVector,
            pYVector,
            pStdVector,
            nRows,
            pParameterVector,
            pConstraintVector,
            nNumberOfParams,
            ppCovarianceMatrix,
            ppAlphaMatrix,
            &dCurrentChiSquare,
            pFittingCallback,
            &dLamda);


    //Copy the results.
    *pChiSquare = dCurrentChiSquare;
	*pMaxIterations = nIterationCounter;

    //Reset the global pointers so that no harms is done accidently.
    ::ppGlobalData=NULL;
	::nGlobalDimension=-1;
	::nGlobalNumberOfPoints=-1;

    //Free the allocate resources.
    free_vector(pXVector,1,nRows);
    free_vector(pYVector,1,nRows);
    free_matrix(ppCovarianceMatrix,1,nNumberOfParams,1,nNumberOfParams);
    free_matrix(ppAlphaMatrix,1,nNumberOfParams,1,nNumberOfParams);

    //return with function status.
    return 1;
}

																						
//Callback for calculating partial derivatives for cylinder-fitting.
//Uses orthogonal distance as figure of merit.
//As this function is called too often so no error checking is done.
//So before calling make sure what you are upto.
static void CylinderFittingCallbackWithoutConstraint(
				double dX,
                double pParameterVector[],
                double* pFunctionValue,
                double pDerivativeVector[],
                int nVectorSize)
{
    double a1,a2,a3;
    double xo1,xo2,xo3;
    double xi1,xi2,xi3;
    double r;
    double t0,s1,s2;
    double d1,d2;
    int i=0;
    int nIndex = dX;
    double dDotProduct;
    double dMagnitude;

    //Note that only in the update corresponding to first index we need to normalize.
    if(nIndex==1)
    {
		//Normalize the direction vector. Otherwise may cause numerical instability.
		dMagnitude = sqrt(pParameterVector[1]*pParameterVector[1]+pParameterVector[2]*pParameterVector[2]+pParameterVector[3]*pParameterVector[3]);
		
		pParameterVector[1]=pParameterVector[1]/dMagnitude;
		pParameterVector[2]=pParameterVector[2]/dMagnitude;
		pParameterVector[3]=pParameterVector[3]/dMagnitude;

		//Replace the postion vector by the point on direction vector nearest to origin.
		dDotProduct = 0;
		for(i=1;i<=3;i++)
		{
			dDotProduct=dDotProduct-pParameterVector[i]*pParameterVector[i+3];
		}
		for(i=1;i<=3;i++)
		{
			pParameterVector[i+3]=pParameterVector[i+3]+dDotProduct*pParameterVector[i];
		}
    }
	
	//update local variables.
	a1 = pParameterVector[1];
    a2 = pParameterVector[2];
    a3 = pParameterVector[3];
  
    xo1 = pParameterVector[4];
    xo2 = pParameterVector[5];
    xo3 = pParameterVector[6];
    r = pParameterVector[7];
    xi1 = ::ppGlobalData[nIndex][1];
    xi2 = ::ppGlobalData[nIndex][2];
    xi3 = ::ppGlobalData[nIndex][3];
    
    double dx3 = xi3-xo3;
	double dx2 = xi2-xo2;
	double dx1 = xi1-xo1;

    //Calculate partial derivatives for all 7 parameters.
    //Code taken from ccode() routine of MatLab.
	
	//Calculate the common part once.
	d1 = 1/(sqrt(pow(a2*(dx3)-a3*(dx2),2.0)+pow(a3*(dx1)-a1*(dx3),2.0)+pow(a1*(dx2)-a2*(dx1),2.0)));
	
	//dFdx01
	pDerivativeVector[4] = d1*(-2.0*(a3*(dx1)-a1*(dx3))*a3+2.0*(a1*(dx2)-a2*(dx1))*a2)/2.0;

	//dFdx02 =
    pDerivativeVector[5] = d1*(2.0*(a2*(dx3)-a3*(dx2))*a3-2.0*(a1*(dx2)-a2*(dx1))*a1)/2.0;

	//dFdx03 =
	pDerivativeVector[6]=d1*(-2.0*(a2*(dx3)-a3*(dx2))*a2+2.0*(a3*(dx1)-a1*(dx3))*a1)/2.0;

	//Pre-calculate
	d2 = 1/sqrt((-2.0*a2*xo3*a3*xo2+2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a3*xi1*a1*xi3-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xi1*xi1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a2*a2*xi1*xi1+a2*a2*xo1*xo1+a3*a3*xo1*xo1-2.0*a2*a2*xi1*xo1-2.0*a1*a1*xi3*xo3-2.0*a3*a3*xi1*xo1+a3*a3*xo2*xo2-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi2*xo2+a1*a1*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);
    
    //dFda01 =
    s1 = -a2*xo2+a2*xi2+xi3*a3+xi1*a1-xo1*a1-a3*xo3;
    s2 = (-a1*xo2*a2+a3*a3*xo1+xo1*a2*a2-a3*a3*xi1-xi1*a2*a2+a1*xi2*a2+xi3*a3*a1-a3*a1*xo3)*d2;      
	pDerivativeVector[1]=s1*s2;

	//dFda02 =
  	s1 = (-a1*a1*xo2+a1*xo1*a2-xi3*a3*a2+a3*xo3*a2-a3*a3*xo2+a1*a1*xi2+a3*a3*xi2-a1*xi1*a2)*(a3*xo3+a2*xo2+a1*xo1-xi3*a3-a2*xi2-a1*xi1); 
    pDerivativeVector[2]=s1*d2;

    //dFda03 =
    s1 = xi3*a1*a1-a3*a1*xi1+a3*xo2*a2+xi3*a2*a2+a3*a1*xo1-xo3*a1*a1-xo3*a2*a2-a3*xi2*a2;      
    s2 = (a2*xo2-xi3*a3-a1*xi1+a1*xo1+xo3*a3-a2*xi2)*d2;      
	pDerivativeVector[3]=s1*s2;
    
    pDerivativeVector[7]=-1;

    //The goodness of fit is given by the difference of orthogonal distance from estimated radius.
	*pFunctionValue = (1/d1) -r ;
}

double CylinderPointDistance(Vector3D pt,Vector3D axis,Vector3D pointOnAxis,double radius)
{
	axis = axis.Normalize();
	
	//convert point on axis to point on axis closest to origin.
	Vector3D p = pointOnAxis - axis*axis.DotProduct(pointOnAxis);
	
	Vector3D v = (pt-p);
	return ((axis.VectorProduct(v)).Length()-radius);
}

void GetNumericalDerivativesCylinder(Vector3D pt,
				double pP[],
                double* pF,
                double pD[])
{
	*pF = CylinderPointDistance(pt,Vector3D(pP[1],pP[2],pP[3]),
								Vector3D(pP[4],pP[5],pP[6]),pP[7]);
	double stepSize = 1e-5;
	
	for(int i=1;i<=7;i++)
	{
		double old = pP[i];
		pP[i]+=stepSize;
		double distance = CylinderPointDistance(pt,Vector3D(pP[1],pP[2],pP[3]),
								Vector3D(pP[4],pP[5],pP[6]),pP[7]);
		pD[i] = (distance-*pF)/(pP[i]-old);
		pP[i]=old;
	}
}				


static void CylinderFittingCallbackWithConstraint(
				double dX,
                double pParameterVector[],
                double* pFunctionValue,
                double pDerivativeVector[],
                int nVectorSize)
{
    double a1,a2,a3;
    double xo1,xo2,xo3;
    double xi1,xi2,xi3;
    double r;
    double t0,s1,s2;
    double d1,d2;
    int i=0;
    int nIndex = dX;
    double dDotProduct;
    double dMagnitude;
		
    //Note that only in the update corresponding to first index we need to normalize.
    if(nIndex==1)
    {		
		dMagnitude = sqrt(pParameterVector[1]*pParameterVector[1]+pParameterVector[2]*pParameterVector[2]+pParameterVector[3]*pParameterVector[3]);
		
		/*
		pParameterVector[1]=pParameterVector[1]/dMagnitude;
		pParameterVector[2]=pParameterVector[2]/dMagnitude;
		pParameterVector[3]=pParameterVector[3]/dMagnitude;
		*/
		
		//Replace the postion vector by the point on direction vector nearest to origin.
#if 0		
		dDotProduct = 0;
		for(i=1;i<=3;i++)
		{
			dDotProduct=dDotProduct-pParameterVector[i]*pParameterVector[i+3];
		}
		for(i=1;i<=3;i++)
		{
			pParameterVector[i+3]=pParameterVector[i+3]+dDotProduct*pParameterVector[i]/dMagnitude;
		}
#endif		
		
		//Fill the derivatve vector.
		fprintf(stderr," CylinderFittingCallbackWithConstraint weight: %f\n",weight);
		
		for(int i=1;i<=7;i++)
			fprintf(stderr,"%d: %f   ",i,pParameterVector[i]);
		fprintf(stderr,"\n");
		
		pDerivativeVector[1] = weight*pParameterVector[1]/dMagnitude;
		pDerivativeVector[2] = weight*pParameterVector[2]/dMagnitude;
		pDerivativeVector[3] = weight*pParameterVector[3]/dMagnitude;
		for(i=4;i<=7;i++)
			pDerivativeVector[i] = 0;
		*pFunctionValue = weight*(dMagnitude-1);
		cerr<<"Constraint 1: "<<*pFunctionValue<<endl;
    }
	else if(nIndex==2)
	{
		dDotProduct = 0;
		for(i=1;i<=3;i++)
		{
			dDotProduct+=pParameterVector[i]*pParameterVector[i+3];
		}
		
		pDerivativeVector[1] = weight*pParameterVector[4];
		pDerivativeVector[2] = weight*pParameterVector[5];
		pDerivativeVector[3] = weight*pParameterVector[6];
		pDerivativeVector[4] = weight*pParameterVector[1];
		pDerivativeVector[5] = weight*pParameterVector[2];
		pDerivativeVector[6] = weight*pParameterVector[3];
		pDerivativeVector[7] = 0;
		*pFunctionValue = weight*(dDotProduct);
		
#if 0		
		//Make it independent of magnitude.
		Vector3D axis(pParameterVector[1],pParameterVector[2],pParameterVector[3]);
		Vector3D pos(pParameterVector[4],pParameterVector[5],pParameterVector[6]);
		double la = axis.Length();
		double lp = pos.Length();
		double factor = 1/(la*lp);
		pDerivativeVector[1] = weight*factor*(pParameterVector[4]-pow(pParameterVector[1],2)*pParameterVector[4]/(la*la));
		pDerivativeVector[2] = weight*factor*(pParameterVector[5]-pow(pParameterVector[2],2)*pParameterVector[5]/(la*la));
		pDerivativeVector[3] = weight*factor*(pParameterVector[6]-pow(pParameterVector[3],2)*pParameterVector[6]/(la*la));
		pDerivativeVector[4] = weight*factor*(pParameterVector[1]-pow(pParameterVector[4],2)*pParameterVector[1]/(lp*lp));
		pDerivativeVector[5] = weight*factor*(pParameterVector[2]-pow(pParameterVector[5],2)*pParameterVector[2]/(lp*lp));
		pDerivativeVector[6] = weight*factor*(pParameterVector[3]-pow(pParameterVector[6],2)*pParameterVector[3]/(lp*lp));
		pDerivativeVector[7] = 0;
		*pFunctionValue = weight*(dDotProduct)*factor;
#endif		
		
		cerr<<"Constraint 2: "<<*pFunctionValue<<endl;

	}
	
	else if(nIndex==3)
	{
		for(int i=1;i<=7;i++)
			pDerivativeVector[i] = 0;
		pDerivativeVector[7] = weight*(pParameterVector[7]<0);
				
		*pFunctionValue = weight*(0);
		cerr<<"Constraint 3: "<<*pFunctionValue<<endl;
	}
	
	else
	{
	
		
		//update local variables.
		a1 = pParameterVector[1];
		a2 = pParameterVector[2];
		a3 = pParameterVector[3];

		xo1 = pParameterVector[4];
		xo2 = pParameterVector[5];
		xo3 = pParameterVector[6];
		r = pParameterVector[7];
		xi1 = ::ppGlobalData[nIndex][1];
		xi2 = ::ppGlobalData[nIndex][2];
		xi3 = ::ppGlobalData[nIndex][3];
		
		GetNumericalDerivativesCylinder(Vector3D(xi1,xi2,xi3),
					pParameterVector,
                	pFunctionValue,pDerivativeVector);
        return;

		double dx3 = xi3-xo3;
		double dx2 = xi2-xo2;
		double dx1 = xi1-xo1;

		//Calculate partial derivatives for all 7 parameters.
		//Code taken from ccode() routine of MatLab.

		//Calculate the common part once.
		d1 = 1/(sqrt(pow(a2*(dx3)-a3*(dx2),2.0)+pow(a3*(dx1)-a1*(dx3),2.0)+pow(a1*(dx2)-a2*(dx1),2.0)));

		//dFdx01
		pDerivativeVector[4] = d1*(-2.0*(a3*(dx1)-a1*(dx3))*a3+2.0*(a1*(dx2)-a2*(dx1))*a2)/2.0;

		//dFdx02 =
		pDerivativeVector[5] = d1*(2.0*(a2*(dx3)-a3*(dx2))*a3-2.0*(a1*(dx2)-a2*(dx1))*a1)/2.0;

		//dFdx03 =
		pDerivativeVector[6]=d1*(-2.0*(a2*(dx3)-a3*(dx2))*a2+2.0*(a3*(dx1)-a1*(dx3))*a1)/2.0;

		//Pre-calculate
		d2 = 1/sqrt((-2.0*a2*xo3*a3*xo2+2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a3*xi1*a1*xi3-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xi1*xi1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a2*a2*xi1*xi1+a2*a2*xo1*xo1+a3*a3*xo1*xo1-2.0*a2*a2*xi1*xo1-2.0*a1*a1*xi3*xo3-2.0*a3*a3*xi1*xo1+a3*a3*xo2*xo2-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi2*xo2+a1*a1*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);

		//dFda01 =
		s1 = -a2*xo2+a2*xi2+xi3*a3+xi1*a1-xo1*a1-a3*xo3;
		s2 = (-a1*xo2*a2+a3*a3*xo1+xo1*a2*a2-a3*a3*xi1-xi1*a2*a2+a1*xi2*a2+xi3*a3*a1-a3*a1*xo3)*d2;      
		pDerivativeVector[1]=s1*s2;

		//dFda02 =
		s1 = (-a1*a1*xo2+a1*xo1*a2-xi3*a3*a2+a3*xo3*a2-a3*a3*xo2+a1*a1*xi2+a3*a3*xi2-a1*xi1*a2)*(a3*xo3+a2*xo2+a1*xo1-xi3*a3-a2*xi2-a1*xi1); 
		pDerivativeVector[2]=s1*d2;

		//dFda03 =
		s1 = xi3*a1*a1-a3*a1*xi1+a3*xo2*a2+xi3*a2*a2+a3*a1*xo1-xo3*a1*a1-xo3*a2*a2-a3*xi2*a2;      
		s2 = (a2*xo2-xi3*a3-a1*xi1+a1*xo1+xo3*a3-a2*xi2)*d2;      
		pDerivativeVector[3]=s1*s2;

		pDerivativeVector[7]=-1;

		//The goodness of fit is given by the difference of orthogonal distance from estimated radius.
		*pFunctionValue = (1/d1) -r ;
	}
}

//Fit Cylinder using Levenberg-Marquardt method.
// ppData:				input X,Y,Z matrix.
// nRows:				Number of rows
// nCols: 				Number of columns, must be atleast 3.
// pStdVector:			Standard deviation of each measurement.
// pConstraintVector:   Must be at least 7x1. If 0 keep that param fixed.
// pParameterVector:	Seed values, must be 7x1.
// pChiSquare:			Has final chisquare on return.
// pMaxIteration:		Has allowed max iterations on entry, and has final iteration count
//						on return.

bool globalUseConstraintWithCylinderFitting = false;
int FitCylinderLMQ(double** ppData,
					int nRows,
                    int nCols,
                    double* pStdVector,
                    int* pConstraintVector,
                    double* pParameterVector,
                    double* pChiSquare,
                    int* pMaxIterations)
{
	const int nNumberOfParams = 7;
	
/*
	//****************** For testing only ***************************
	// Change the approximate value to check the range of convergence
	// **************************************************************	
	for(int i=1;i<=3;i++)
			pParameterVector[i]*=1.1;
	for(int i=4;i<=6;i++)
			pParameterVector[i]*=1.0;
	pParameterVector[7] += 10;
*/	
	
	if(globalUseConstraintWithCylinderFitting)
	{
		//Request the weighting parameters, to be use in constrained optimization
		//using multiplier method.
		cerr<<"weightMultiplier?";
		cin>>weightMultiplier;
		cerr<<"weightStart?";
		cin>>weightStart;
		weight = weightStart;
		
		double oldParams[8];
		for(int i=0;i<=10;i++)
		{
			cerr<<"\n***********************************************\n";
			cerr<<"---- Iter: "<<i<<"  weight: "<<weight<<" ------"<<endl;
			cerr<<"***********************************************\n";
			*pMaxIterations = 10;
			for(int k=1;k<=7;k++)
				oldParams[k]=pParameterVector[k];
			
			FitLMQConstrained(ppData,
   			nRows,
			nCols,
			pStdVector,
			pConstraintVector,
			pParameterVector,
			pChiSquare,
			pMaxIterations,
			nNumberOfParams,
			CylinderFittingCallbackWithConstraint,
			false);
			weight = weight*weightMultiplier;
			
			double diff=0;
			for(int k=1;k<=7;k++)
				diff += fabs(oldParams[k]-pParameterVector[k]);
			if(diff<1e-6)
			{
				cerr<<"\nChange is Parameters is only "<<diff<<" breaking\n";
				break;
			}
		}
		
		Vector3D axis(pParameterVector[1],pParameterVector[2],pParameterVector[3]);
		Vector3D pointOnAxis(pParameterVector[4],pParameterVector[5],pParameterVector[6]);
		axis = axis.Normalize();
		//convert point on axis to point on axis closest to origin.
		Vector3D p = pointOnAxis - axis*axis.DotProduct(pointOnAxis);
		
		pParameterVector[1] = axis.X();
		pParameterVector[2] = axis.Y();
		pParameterVector[3] = axis.Z();
		
		pParameterVector[4] = p.X();
		pParameterVector[5] = p.Y();
		pParameterVector[6] = p.Z();
	
		
		return 0;			
			
	}
	else
	{
		return
		FitLMQ(ppData,
				nRows,
				nCols,
				pStdVector,
				pConstraintVector,
				pParameterVector,
				pChiSquare,
				pMaxIterations,
				nNumberOfParams,
				globalUseConstraintWithCylinderFitting? CylinderFittingCallbackWithConstraint:
											CylinderFittingCallbackWithoutConstraint,
											false);
	}

}


void LoadPointsFromeRawFile(double** ppData,int* pSize,char* szFileName)
{
	int i;
	int size;
	FILE* pFile = fopen(szFileName,"rb");
	i=fread(&size,sizeof(int),1,pFile);;
	for(i=1;i<=size;i++)
	{
		fread(&(ppData[i][1]),sizeof(double),1,pFile);
		fread(&(ppData[i][2]),sizeof(double),1,pFile);
		fread(&(ppData[i][3]),sizeof(double),1,pFile);
	}
	fclose(pFile);
	*pSize  = size;
	printf("\n%s read with %d points\n",szFileName,size);
}


//A testing routine to generate cylinder aligned with one of the x-y-z axes.
static void MakeCylinderData(double** ppData,int nRows, int nCols, double* pParameterVector, int *pCount)
{
	double x0=3;
    double y0=1;
    double z0=1;
    double r =2.8885;
    double step = M_PI*2.00/500.00;
    double ix,iy,iz;
    int count = 1;
    int i,j,k;

    #define    NOISE() rand()/(double)(RAND_MAX)*0
    for(iz=0;iz<100;iz++)
    {
        for(ix=0;ix<(M_PI/2);ix+=step)
        {
            ppData[count][1]=r*cos(ix)+x0+NOISE();
            ppData[count][2]=r*sin(ix)+y0+NOISE();
            ppData[count][3]=iz/1.00+NOISE()+z0;
            count++;
            if(count > nRows)
            	break;
    	}
        if(count > nRows)
            	break;
    }
	printf("Circle points are: %d",count);
	
	for(i=1;i<=7;i++)
    	pParameterVector[i]=1+rand()/(double)RAND_MAX;
	
	pParameterVector[1]=1;
	pParameterVector[2]=0;
	pParameterVector[3]=0.89;
	pParameterVector[4]=1;
	pParameterVector[5]=2;
	pParameterVector[6]=3;
	pParameterVector[5]=30;
	
	
}


//Test Cylinder fitting rountine with dummy data.
void TestFitCylinderLMQ(void)
{

	double* pStdVector;
	int* pConstraintVector;
    double* pParameterVector;
    double dChiSquare;
    double** ppData;
	int nRows = 1000000;
    int nCols = 7;
    int nCount = 0;
    int nMaxIterations = 1000;
    int i;

    //Allocate memory.
    pStdVector=dvector(1,nRows);
	pConstraintVector=ivector(1,nRows);
    pParameterVector=dvector(1,nCols);
    ppData=matrix(1,nRows,1,nCols);
	pStdVector=dvector(1,nRows);

	//Make cylinder data.
    printf("TestCylinderLMQ: Making synthetic cylinder\n");
    MakeCylinderData(ppData,nRows,nCols,pParameterVector,&nCount);

    //initialize.
    for(i=1;i<=nRows;i++)
    {
    	pStdVector[i]=1;
        pConstraintVector[i]=1;
    }

    //Now check the function.
	FitCylinderLMQ(ppData,
    				nCount,
    				nCols,
    				pStdVector,
    				pConstraintVector,
    				pParameterVector,
                    &dChiSquare,
                    &nMaxIterations);
    printf("TestCylinderLMQ: Done!!!\n");

    //Free the allocate resources.
    free_vector(pStdVector,1,nRows);
	free_ivector(pConstraintVector,1,nRows);
    free_vector(pParameterVector,1,nCols);
    free_matrix(ppData,1,nRows,1,nCols);
}

//Callback for calculating partial derivatives for 3D Line fitting.
//Uses orthogonal distance as figure of merit.
//As this function is called too often so no error checking is done.
//Quite similar to line fitting callback just the R is missing.
static void Line3DFittingCallback(
				double dX,
                double pParameterVector[],
                double* pFunctionValue,
                double pDerivativeVector[],
                int nVectorSize)
{
    double a1,a2,a3;
    double xo1,xo2,xo3;
    double xi1,xi2,xi3;
    double t0,s1,s2;
    int i=0;
    int nIndex = dX;
    double dDotProduct;
    double dMagnitude;

    //Normalization needs to be done only in the first iteration.
    if(nIndex==1)
    {
		//Normalize the direction vector. Otherwise may cause numerical instability.
		dMagnitude = sqrt(pParameterVector[1]*pParameterVector[1]+pParameterVector[2]*pParameterVector[2]+pParameterVector[3]*pParameterVector[3]);

		pParameterVector[1]=pParameterVector[1]/dMagnitude;
		pParameterVector[2]=pParameterVector[2]/dMagnitude;
		pParameterVector[3]=pParameterVector[3]/dMagnitude;

		//Replace the postion vector by the point on direction vector nearest to origin.
		dDotProduct = 0;
		for(i=1;i<=3;i++)
		{
			dDotProduct=dDotProduct-pParameterVector[i]*pParameterVector[i+3];
		}
		for(i=1;i<=3;i++)
		{
			pParameterVector[i+3]=pParameterVector[i+3]+dDotProduct*pParameterVector[i];
		}
	}
	
	//Update local variables.
	a1 = pParameterVector[1];
	a2 = pParameterVector[2];
	a3 = pParameterVector[3];

    xo1 = pParameterVector[4];
    xo2 = pParameterVector[5];
    xo3 = pParameterVector[6];
    xi1 = ::ppGlobalData[nIndex][1];
    xi2 = ::ppGlobalData[nIndex][2];
    xi3 = ::ppGlobalData[nIndex][3];
    
    double dx3 = xi3-xo3;
	double dx2 = xi2-xo2;
	double dx1 = xi1-xo1;

    //Calculate partial derivatives for all 7 parameters.
    //Code taken from ccode() routine of MatLab.
    //dFdx01
	t0 = 1/(sqrt(pow(a2*(dx3)-a3*(dx2),2.0)+pow(a3*(dx1)-a1*(dx3),2.0)+pow(a1*(dx2)-a2*(dx1),2.0)))*(-2.0*(a3*(dx1)-a1*(dx3))*a3+2.0*(a1*(dx2)-a2*(dx1))*a2)/2.0;
    pDerivativeVector[4]=t0;

	//dFdx02 =
    t0 = 1/(sqrt(pow(a2*(dx3)-a3*(dx2),2.0)+pow(a3*(dx1)-a1*(dx3),2.0)+pow(a1*(dx2)-a2*(dx1),2.0)))*(2.0*(a2*(dx3)-a3*(dx2))*a3-2.0*(a1*(dx2)-a2*(dx1))*a1)/2.0;
	pDerivativeVector[5]=t0;

	//dFdx03 =
	t0 = 1/(sqrt(pow(a2*(dx3)-a3*(dx2),2.0)+pow(a3*(dx1)-a1*(dx3),2.0)+pow(a1*(dx2)-a2*(dx1),2.0)))*(-2.0*(a2*(dx3)-a3*(dx2))*a2+2.0*(a3*(dx1)-a1*(dx3))*a1)/2.0;
    pDerivativeVector[6]=t0;

	//dFda01 =
    s1 = -a2*xo2+a2*xi2+xi3*a3+xi1*a1-xo1*a1-a3*xo3;      s2 = (-a1*xo2*a2+a3*a3*xo1+xo1*a2*a2-a3*a3*xi1-xi1*a2*a2+a1*xi2*a2+xi3*a3*a1-a3*a1*xo3)/sqrt((-2.0*a2*xo3*a3*xo2+2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a3*xi1*a1*xi3-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xi1*xi1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a2*a2*xi1*xi1+a2*a2*xo1*xo1+a3*a3*xo1*xo1-2.0*a2*a2*xi1*xo1-2.0*a1*a1*xi3*xo3-2.0*a3*a3*xi1*xo1+a3*a3*xo2*xo2-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi2*xo2+a1*a1*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      t0 = s1*s2;
	pDerivativeVector[1]=t0;

	//dFda02 =
  	s1 = (-a1*a1*xo2+a1*xo1*a2-xi3*a3*a2+a3*xo3*a2-a3*a3*xo2+a1*a1*xi2+a3*a3*xi2-a1*xi1*a2)*(a3*xo3+a2*xo2+a1*xo1-xi3*a3-a2*xi2-a1*xi1);      s2 = 1/sqrt((-2.0*a2*xo3*a3*xo2+2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a3*xi1*a1*xi3-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xi1*xi1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a2*a2*xi1*xi1+a2*a2*xo1*xo1+a3*a3*xo1*xo1-2.0*a2*a2*xi1*xo1-2.0*a1*a1*xi3*xo3-2.0*a3*a3*xi1*xo1+a3*a3*xo2*xo2-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi2*xo2+a1*a1*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      t0 = s1*s2;
    pDerivativeVector[2]=t0;

    //dFda03 =
    s1 = xi3*a1*a1-a3*a1*xi1+a3*xo2*a2+xi3*a2*a2+a3*a1*xo1-xo3*a1*a1-xo3*a2*a2-a3*xi2*a2;      s2 = (a2*xo2-xi3*a3-a1*xi1+a1*xo1+xo3*a3-a2*xi2)/sqrt((-2.0*a2*xo3*a3*xo2+2.0*a2*xo3*a3*xi2+2.0*a2*xi3*a3*xo2-2.0*a2*xi3*a3*xi2-2.0*a3*xi1*a1*xi3-2.0*a3*xo1*a1*xo3+2.0*a3*xo1*a1*xi3+2.0*a3*xi1*a1*xo3+2.0*a1*xi2*a2*xo1-2.0*a1*xi2*a2*xi1-2.0*a1*xo2*a2*xo1+2.0*a1*xo2*a2*xi1+a2*a2*xi3*xi3+a2*a2*xo3*xo3+a3*a3*xi2*xi2+a3*a3*xi1*xi1+a1*a1*xi3*xi3+a1*a1*xo3*xo3+a1*a1*xi2*xi2+a2*a2*xi1*xi1+a2*a2*xo1*xo1+a3*a3*xo1*xo1-2.0*a2*a2*xi1*xo1-2.0*a1*a1*xi3*xo3-2.0*a3*a3*xi1*xo1+a3*a3*xo2*xo2-2.0*a2*a2*xi3*xo3-2.0*a3*a3*xi2*xo2-2.0*a1*a1*xi2*xo2+a1*a1*xo2*xo2)/(a1*a1+a2*a2+a3*a3))/pow(a1*a1+a2*a2+a3*a3,2.0);      t0 = s1*s2;
	pDerivativeVector[3]=t0;

    //Evaluate the distance function.
	t0 = sqrt(pow(a2*(dx3)-a3*(dx2),2.0)+pow(a3*(dx1)-a1*(dx3),2.0)+pow(a1*(dx2)-a2*(dx1),2.0));

    //The goodness of fit is given by the difference of orthogonal distance from estimated radius.
	*pFunctionValue = t0  ;
}

//Fit Line3D using Levenberg-Marquardt method.
// ppData:				input X,Y,Z matrix.
// nRows:				Number of rows
// nCols: 				Number of columns, must be atleast 3.
// pStdVector:			Standard deviation of each measurement.
// pConstraintVector:   Must be at least 7x1. If 0 keep that param fixed.
// pParameterVector:	Seed values, must be 7x1.
// pChiSquare:			Has final chisquare on return.
// pMaxIteration:		Has allowed max iterations on entry, and has final iteration count
//						on return.

int FitLine3DLMQ(double** ppData,
					int nRows,
                    int nCols,
                    double* pStdVector,
                    int* pConstraintVector,
                    double* pParameterVector,
                    double* pChiSquare,
                    int* pMaxIterations)
{
	const int nNumberOfParams = 6;
    return
    FitLMQ(ppData,
   			nRows,
			nCols,
			pStdVector,
			pConstraintVector,
			pParameterVector,
			pChiSquare,
			pMaxIterations,
			nNumberOfParams,
			Line3DFittingCallback);

}



//A testing routine to generate cylinder aligned with one of the x-y-z axes.
static void MakeLine3DData(double** ppData,int nRows, int nCols, double* pParameterVector, int *pCount)
{
    double x0=-22.01;
    double y0=21.0010;
    double z0=21.0020;
    double x1 = 5;
    double y1 = 4;
    double z1 = 4;
    double mag = sqrt(pow(x1-x0,2)+pow(y1-y0,2)+pow(z1-z0,2));
    double tx =(x1-x0)/mag;
    double ty = (y1-y0)/mag;
    double tz = (z1-z0)/mag;
    double step = 1.200/(double)(nRows);
    double ix,iy,iz;
    int count = 1;
    int i,j,k;

	#define    NOISE() rand()/(double)(RAND_MAX)*0.0000000*1
    for(ix=0;ix<1;ix+=step)
    {
    	ppData[count][1]=ix*tx+x0+NOISE();
        ppData[count][2]=ix*ty+y0+NOISE();
        ppData[count][3]=ix*tz+z0+NOISE();
        count++;
        if(count > nRows)
            	break;
    }
	printf("Line points are: %d",count);

    double dNoiseFactor=0.1;
    pParameterVector[1]=(1+dNoiseFactor*rand()/(double)RAND_MAX)*tx;
    pParameterVector[2]=(1+dNoiseFactor*rand()/(double)RAND_MAX)*ty;
    pParameterVector[3]=(1+dNoiseFactor*rand()/(double)RAND_MAX)*tz;
    pParameterVector[4]=(1+dNoiseFactor*rand()/(double)RAND_MAX)*x0;
    pParameterVector[5]=(1+dNoiseFactor*rand()/(double)RAND_MAX)*y0;
    pParameterVector[6]=(1+dNoiseFactor*rand()/(double)RAND_MAX)*z0;
    *pCount = count;
}


//Test Line fitting rountine with dummy data.
void TestFitLine3DLMQ(void)
{

	double* pStdVector;
	int* pConstraintVector;
    double* pParameterVector;
    double dChiSquare;
    double** ppData;
	int nRows = 100000;
    int nCols = 6;
    int nCount = 0;
    int nMaxIterations = 30;
    int i;

    //Allocate memory.
    pStdVector=dvector(1,nRows);
	pConstraintVector=ivector(1,nRows);
    pParameterVector=dvector(1,nCols);
    ppData=matrix(1,nRows,1,nCols);
	pStdVector=dvector(1,nRows);

	//Make cylinder data.
    printf("TestLineLMQ: Making synthetic Line3D\n");
    MakeLine3DData(ppData,nRows,nCols,pParameterVector,&nCount);

    //initialize.
    for(i=1;i<=nRows;i++)
    {
    	pStdVector[i]=1;
        pConstraintVector[i]=1;
    }

    //Now check the function.
	FitLine3DLMQ(ppData,
    				nCount,
    				nCols,
    				pStdVector,
    				pConstraintVector,
    				pParameterVector,
                    &dChiSquare,
                    &nMaxIterations);
    printf("TestLine3DLMQ: Done!!!\n");

    //Free the allocate resources.
    free_vector(pStdVector,1,nRows);
	free_ivector(pConstraintVector,1,nRows);
    free_vector(pParameterVector,1,nCols);
    free_matrix(ppData,1,nRows,1,nCols);

}




void TestEigFitting()
{
	double** ppData;
	int nRows = 10000;
	int nCols = 3;
	int i,j;
	double dDC = 20;
	double dResidual = 0;
	
	ppData = AllocateMatrixD(nRows,nCols);
	
	//Generate a test set.
	for(i=1;i <= nRows; i++)
	{
		double x = i/100.00; 
		double y = i%100; 
		double* pTemp = ppData[i];
		
		pTemp[1] = x;
		pTemp[2] = y;
	}
	
	double* pAns = AllocateVectorD(100);
	
	//Test the fitting function.
	printf("***** Quadratic surface *****\n");
	for(i=1;i <= nRows; i++)
	{
		double* pTemp = ppData[i];
		double x = pTemp[1]; 
		double y = pTemp[2]; 
		pTemp[3] = x*x + y*y + y + dDC;
	}
	FitQuadraticSurfaceEig(ppData,nRows,nCols,pAns,&dResidual-1);
	PrintVectorD(pAns,10,"Answer");
	
	printf("***** Plane *****\n");
	for(i=1;i <= nRows; i++)
	{
		double* pTemp = ppData[i];
		double x = pTemp[1]; 
		double y = pTemp[2]; 
		pTemp[3] = x + y + dDC;
	}
	FitPlaneEig(ppData,nRows,nCols,pAns,&dResidual-1);
	PrintVectorD(pAns,10,"Answer");

	printf("***** Biquad *****\n");
	for(i=1;i <= nRows; i++)
	{
		double* pTemp = ppData[i];
		double x = pTemp[1]; 
		double y = pTemp[2]; 
		pTemp[3] = x*x + y*y + y + dDC;
	}
	FitBiquadraticEig(ppData,nRows,nCols,pAns,&dResidual-1);
	PrintVectorD(pAns,10,"Answer");
	
	printf("***** Bicubic *****\n");
	for(i=1;i <= nRows; i++)
	{
		double* pTemp = ppData[i];
		double x = pTemp[1]; 
		double y = pTemp[2]; 
		pTemp[3] = x*x*x + y*y*y + dDC;
	}
	FitBicubicEig(ppData,nRows,nCols,pAns,&dResidual-1);
	PrintVectorD(pAns,10,"Answer");
	
	printf("***** Line *****\n");
	for(i=1;i <= nRows; i++)
	{
		double* pTemp = ppData[i];
		double x = pTemp[1]; 
		pTemp[2] = 3*x + dDC;
	}
	FitLineEig(ppData,nRows,nCols,pAns,&dResidual-1);
	PrintVectorD(pAns,10,"Answer");
	
	printf("***** Polynomial *****\n");
	for(i=1;i <= nRows; i++)
	{
		double* pTemp = ppData[i];
		double x = pTemp[1]; 
		pTemp[2] = 5*x*x + 3*x + dDC;
	}
	FitPolyEig(ppData,nRows,nCols,2,pAns,&dResidual-1);
	PrintVectorD(pAns,10,"Answer");
	
	//Deallocate resources.
	DeallocateMatrixD(ppData,nRows,nCols);
	DeallocateVectorD(pAns,100);
	
}

//Fits a biquadratic function to given data. The form of function is
// a1*x^2 + a2*y^2 + a3*x*y + a4*x + a5*y + a6*z + a7*d = 0
// Number of unknown parameters is 7.
// The function inputs are similar to FitEig function.
int FitBiquadraticEig(double** ppXYZ,int nRows,int nCols,double* pAns,double* pChiSquare)
{
	const int params = 6;
	double** ppData = AllocateMatrixD(nRows,params);
	int i,j,k;
	
	//Fill in the matrix for biquadratic case.
	for(i=1;i<nRows;i++)
	{
		ppData[i][1] = ppXYZ[i][1]*ppXYZ[i][1];//x^2
		ppData[i][2] = ppXYZ[i][2]*ppXYZ[i][2];//y^2
		ppData[i][3] = ppXYZ[i][1]*ppXYZ[i][2];//x*y
		ppData[i][4] = ppXYZ[i][1];//x
		ppData[i][5] = ppXYZ[i][2];//y
		ppData[i][6] = ppXYZ[i][3];//z
	}
	FitEig(ppData,nRows,params,pAns,pChiSquare);
	
	DeallocateMatrixD(ppData,nRows,params);
}
int FitTruncatedBiquadraticLsq(double** ppXYZ,int nRows,int nCols,double* pAns,double* pChiSquare)	
{
	const int params = 4;;
	double** ppData = AllocateMatrixD(nRows,params);
	double* pZ = AllocateVectorD(nRows);

	//Fill in the matrix for biquadratic case.
	for(int i=1;i<nRows;i++)
	{
		ppData[i][1] = ppXYZ[i][1]*ppXYZ[i][1];//x^2
		ppData[i][2] = ppXYZ[i][2]*ppXYZ[i][2];//y^2
		ppData[i][3] = ppXYZ[i][1]*ppXYZ[i][2];//x*y
		ppData[i][4] = 1;
		pZ[i] = ppXYZ[i][3];
	}
	
	SolveUsingSvd(ppData,pZ,pAns,nRows,params);
	
	DeallocateMatrixD(ppData,nRows,params);
	DeallocateVectorD(pZ,nRows);
}

int FitBiquadraticLsq(double** ppXYZ,int nRows,int nCols,double* pAns,double* pChiSquare)	
{
	const int params = 6;
	double** ppData = AllocateMatrixD(nRows,params);
	double* pZ = AllocateVectorD(nRows);

	//Fill in the matrix for biquadratic case.
	for(int i=1;i<nRows;i++)
	{
		ppData[i][1] = ppXYZ[i][1]*ppXYZ[i][1];//x^2
		ppData[i][2] = ppXYZ[i][2]*ppXYZ[i][2];//y^2
		ppData[i][3] = ppXYZ[i][1]*ppXYZ[i][2];//x*y
		ppData[i][4] = ppXYZ[i][1];//x
		ppData[i][5] = ppXYZ[i][2];//y
		ppData[i][6] = 1;//dc
		
		pZ[i] = ppXYZ[i][3];
	}
	
	SolveUsingSvd(ppData,pZ,pAns,nRows,params);
	
	DeallocateMatrixD(ppData,nRows,params);
	DeallocateVectorD(pZ,nRows);
}


//Fits a truncated biquadratic function to given data. The form of function is
// a1*x^2 + a2*y^2 + a3*x*y + a4*z + a5*d = 0
// Number of unknown parameters is 5.
// The function inputs are similar to FitEig function.
int FitTruncatedBiquadraticEig(double** ppXYZ,int nRows,int nCols,double* pAns,double* pChiSquare)
{
	const int params = 4;
	double** ppData = AllocateMatrixD(nRows,params);
	int i,j,k;
	
	//Fill in the matrix for biquadratic case.
	for(i=1;i<nRows;i++)
	{
		ppData[i][1] = ppXYZ[i][1]*ppXYZ[i][1];//x^2
		ppData[i][2] = ppXYZ[i][2]*ppXYZ[i][2];//y^2
		ppData[i][3] = ppXYZ[i][1]*ppXYZ[i][2];//x*y
		ppData[i][4] = ppXYZ[i][3];//z
	}
	FitEig(ppData,nRows,params,pAns,pChiSquare);
	
	DeallocateMatrixD(ppData,nRows,params);
}


//Fits a bicubic function to the given data. The form of the function is
// a1*x^3 + a2*y^3 + a3*x^2*y + a4*x*y^2 + a5*x^2 + a6*y^2 + a7*x*y + a8*x + a9*y + a10*z + a11 = 0;
// Number of unknown parameters is 11.
//The inputs are similar to FitEig function 
int FitBicubicEig(double** ppXYZ,int nRows,int nCols,double* pAns,double* pChiSquare)
{
	const int params = 10;
	double** ppData = AllocateMatrixD(nRows,params);
	int i,j,k;
	
	//Fill in the matrix for bicubic case.
	for(i=1;i<nRows;i++)
	{
		double dX = ppXYZ[i][1];
		double dY = ppXYZ[i][2];
		double dZ = ppXYZ[i][3];
		
		ppData[i][1] = dX*dX*dX;//x^3
		ppData[i][2] = dY*dY*dY;//y^3
		ppData[i][3] = dX*dX*dY;//x^2*y
		ppData[i][4] = dX*dY*dY;//x*y^2
		ppData[i][5] = dX*dX; //x^2
		ppData[i][6] = dY*dY; //y^2
		ppData[i][7] = dX*dY; //x*y
		ppData[i][8] = dX; //x
		ppData[i][9] = dY; //y
		ppData[i][10] = dZ; //z
	}
	FitEig(ppData,nRows,params,pAns,pChiSquare);
	
	DeallocateMatrixD(ppData,nRows,params);
}	

//Fits a quadratic surface to given XYZ points.
//Number of params is 10.
// a1*x^2 + a2*y^2 + a3*z^2 + a4*x*y + a5*x*z + a6*y*z + a7*x + a8*y + a9*z + a10 = 0
int FitQuadraticSurfaceEig(double** ppXYZ,int nRows,int nCols,double* pAns,double* pChiSquare)
{
	const int params = 10;
	double** ppData = AllocateMatrixD(nRows,params);
	int i,j,k;
	
	//Fill in the matrix for quadratic surfacecase.
	for(i=1;i<nRows;i++)
	{
		ppData[i][1] = ppXYZ[i][1]*ppXYZ[i][1];//x^2
		ppData[i][2] = ppXYZ[i][2]*ppXYZ[i][2];//y^2
		ppData[i][3] = ppXYZ[i][3]*ppXYZ[i][3];//z^2
		ppData[i][4] = ppXYZ[i][1]*ppXYZ[i][2];//x*y
		ppData[i][5] = ppXYZ[i][1]*ppXYZ[i][3];//x*z
		ppData[i][6] = ppXYZ[i][2]*ppXYZ[i][3];//y*z
		ppData[i][7] = ppXYZ[i][1];//x
		ppData[i][8] = ppXYZ[i][2];//y
		ppData[i][9] = ppXYZ[i][3];//z
		ppData[i][10] = 1;					
	}
	FitEig(ppData,nRows,params,pAns,pChiSquare);
	
	DeallocateMatrixD(ppData,nRows,params);
}
	

//Fits a plane to given data. The function is of the form:
// a1*x + a2*y + a3*z + a4 = 0
// Number of unknown parameters are 4.
// First three correspond to the normal to plane.
int FitPlaneEig(double** ppXYZ,int nRows,int nCols,double* pAns,double* pChiSquare)
{
	const int params = 3;

	//We don't need separate ppData matrix this time.
	//Its same as ppXYZ for plane.
	FitEig(ppXYZ,nRows,params,pAns,pChiSquare);
	
	//FindOrthogonalVectors(ppXYZ,nRows,params,NULL,NULL);
	/*
	double** ppProjectedData = AllocateMatrixD(nRows,nCols);
	PerformPCA(ppXYZ,nRows,nCols,ppProjectedData);
	PrintMatrixD(ppXYZ,nRows,nCols,"Orig Data");
	PrintMatrixD(ppProjectedData,nRows,nCols,"PCA projected Data");
	DeallocateMatrixD(ppProjectedData,nRows,nCols);
	*/



}	

//This function is similar to FitPlaneEig, but also returns the other two axis along with 
int FitPlaneEig3(double** ppData,int nRows,int nCols,Vector3D& n1, Vector3D& n2, Vector3D& n3,
	double* e1, double* e2, double* e3)
{
	const int params = 3;
	
	int i,j,k;
	double** ppMatrix = AllocateMatrixD(params,params);
	double* pMean = AllocateVectorD(params);
	double *pV1 = AllocateVectorD(params);
	double *pV2 = AllocateVectorD(params);
	double *pTemp;
	double dResidual = 0;
	double dChiSquare = 0;

	ZeroMatrixD(ppMatrix,params,params);
	ZeroVectorD(pMean,params);
		
	//Calculate mean for each column.
	for(i=1;i<=nRows ; i++)
	{
		pTemp =ppData[i];
		for(j=1;j <=params;j++)
		{
			pMean[j] += pTemp[j];
		}
	}
	
	for(j=1;j<=params;j++)
	{
		pMean[j]/=(double)nRows;
	}
		
	//Calculate covariance matrix.
	for(j=1;j<=params;j++)
	{
		for(k=1;k<=params;k++)
		{
			for(i=1;i<=nRows;i++)
			{
				ppMatrix[j][k] += ((ppData[i][j]-pMean[j])*(ppData[i][k]-pMean[k]));
			}
		}
	}
		
	//Get eigen-values and eigen-vectors.
	tred2(ppMatrix,params,pV1,pV2);
//	PrintMatrixD(ppMatrix,params,params,"after tred2 ");
	tqli(pV1,pV2,params,ppMatrix);
//	PrintMatrixD(ppMatrix,params,params,"after tqli ");
//	PrintVectorD(pV1,params,"V1");
//	PrintVectorD(pV2,params,"V2");	
	
	//Find the value and index of min eigen-value.
	double dMin = pV1[1];
	int nMinIndex = 1;
	for(j=2;j<=params;j++)
	{
		if(pV1[j]<dMin)
		{
			dMin = pV1[j];
			nMinIndex = j;
		}
	}
	
	//Copy the answer.
	n1 = Vector3D(ppMatrix[1][nMinIndex],ppMatrix[2][nMinIndex],ppMatrix[3][nMinIndex]);
	if(e1)
		*e1 = pV1[nMinIndex];
	
	int count = 0;
	for(j=1;j<=params;j++)
	{
		if(j!=nMinIndex)
		{
			if(!count)
			{
				count++;
				n2 = Vector3D(ppMatrix[1][j],ppMatrix[2][j],ppMatrix[3][j]);
				if(e2)
					*e2 = pV1[j];
			}
			else
			{
				n3 = Vector3D(ppMatrix[1][j],ppMatrix[2][j],ppMatrix[3][j]);
				if(e3)
					*e3 = pV1[j];
			}
		}								
	}
	
	DeallocateVectorD(pMean,params);
	DeallocateMatrixD(ppMatrix,params,params);
	DeallocateVectorD(pV1,params);
	DeallocateVectorD(pV2,params);
}	

//Fits a 2D line to the give XY data. Form of the function is:
// a1*x + a2*y + a3 = 0;
int FitLineEig(double** ppXY,int nRows,int nCols,double* pAns,double* pChiSquare)
{
	const int params = 2;

	//We don't need separate ppData matrix this time.
	//Its same as ppXYZ for plane.
	FitEig(ppXY,nRows,params,pAns,pChiSquare);
}

//Fits a polynomial of given degree to x-y data.
//nDegree specifies the maximum power of fitted polynomial.
//If degree is n the fitted parameters are n+1
// a1*x^n + a2*x^(n-1) + ... + an*x + an+1 = 0
int FitPolyEig(double** ppXY,int nRows,int nCols,int nDegree,double* pAns,double* pChiSquare)
{
	const int params = nDegree+1;

	if(params == 2)
	{
		//We don't need separate ppData matrix this time.
		//Its same as ppXYZ for plane.
		FitEig(ppXY,nRows,params,pAns,pChiSquare);
	}
	else
	{
		double** ppData = AllocateMatrixD(nRows,params);
		double* pTemp;
		int i,j,k;
	
		//Fill in the matrix for bicubic case.
		for(i=1;i<=nRows;i++)
		{
			double dX = ppXY[i][1];
			double dY = ppXY[i][2];
			pTemp = ppData[i];
			pTemp[nDegree+1] = dY;
			pTemp[nDegree]= dX;
			
			for(j=nDegree-1;j>=1;j--)
				pTemp[j] = pTemp[j+1]*dX;
		}
		FitEig(ppData,nRows,params,pAns,pChiSquare);
	
		DeallocateMatrixD(ppData,nRows,params);
	}
}

static double DotProduct(double* pV1,double* pV2,int nSize)
{
	double dAns = 0;
	
	for(int i=1;i<=nSize;i++)
	{
		dAns += (pV1[i]*pV2[i]);		
	}
	return dAns;
}
//Fits an implicit function using least squares.
//The solution is calculated using eigen-vector fit method.
//ppData:				input X,Y,Z matrix.
//nRows:				number of rows.
//nCols:				number of columns.
//pAns:					Vector filled with answer on success. The ans corresponds to
//						minimum eigen-value.
//pChiSquare			If pAnsMax is NULL it can be address of single double
//						If pAnsMax is not NULL must be a vector of size 2.
//pAnMax:				Vector to be filled with eigen-vector corresponding to max eigen value.		    		    
//

int FitEig(double** ppData,int nRows,int nCols,double* pAns,double* pChiSquare,double* pAnsMax)
{
	int params = nCols;
	int i,j,k;
	double** ppMatrix = AllocateMatrixD(params,params);
	double* pMean = AllocateVectorD(params);
	double *pV1 = AllocateVectorD(params);
	double *pV2 = AllocateVectorD(params);
	double *pTemp;
	double dResidual = 0;
	double dChiSquare = 0;

	ZeroMatrixD(ppMatrix,params,params);
	ZeroVectorD(pMean,params);
		
	//Calculate mean for each column.
	for(i=1;i<=nRows ; i++)
	{
		pTemp =ppData[i];
		for(j=1;j <=params;j++)
		{
			pMean[j] += (pTemp[j]/(double)nRows);
		}
	}
	
	//Calculate covariance matrix.
	for(j=1;j<=params;j++)
	{
		for(k=1;k<=params;k++)
		{
			for(i=1;i<=nRows;i++)
			{
				ppMatrix[j][k] += ((ppData[i][j]-pMean[j])*(ppData[i][k]-pMean[k]));
			}
		}
	}
		
	//Get eigen-values and eigen-vectors.
	tred2(ppMatrix,params,pV1,pV2);
//	PrintMatrixD(ppMatrix,params,params,"after tred2 ");
	tqli(pV1,pV2,params,ppMatrix);
//	PrintMatrixD(ppMatrix,params,params,"after tqli ");
//	PrintVectorD(pV1,params,"V1");
//	PrintVectorD(pV2,params,"V2");	
	
	//Find the value and index of min eigen-value.
	double dMin = pV1[1];
	int nMinIndex = 1;
	for(j=2;j<=params;j++)
	{
		if(pV1[j]<dMin)
		{
			dMin = pV1[j];
			nMinIndex = j;
		}
	}
	
	//Copy the answer.
	for(j=1;j<=params;j++)
	{
		pAns[j] = ppMatrix[j][nMinIndex];
	}
	
	//The dc value is the projection of mean on min-eig with opposite sign.
	pAns[params+1]=-DotProduct(pMean,pAns,params);
	//printf("Min Eigen-Value: %g\n",dMin);
	//PrintVectorD(pAns,params+1,"Min Eigen-Vector");
	
	if(pChiSquare)
	{
		//Calculate the residual.
		dChiSquare = 0;
		for(i=1;i<=nRows;i++)
		{
			dResidual = 0;
			for(j=1;j<=params;j++)
			{
				dResidual += ppData[i][j]*pAns[j];
			}
			dResidual += pAns[params+1];
			dChiSquare += (dResidual*dResidual);
		}
		//printf("ChiSquare for MinEig: %g\n",dChiSquare);
		pChiSquare[1] = dChiSquare;
	}

	
	//If maximum eigen-vector is also requested.
	if(pAnsMax)
	{
		//Find the value and index of max eigen-value.
		double dMax = pV1[1];
		int nMaxIndex = 1;
		for(j=2;j<=params;j++)
		{
			if(pV1[j]>dMax)
			{
				dMax = pV1[j];
				nMaxIndex = j;
			}
		}
	
		//Copy the answer.
		for(j=1;j<=params;j++)
		{
			pAnsMax[j] = ppMatrix[j][nMaxIndex];
		}
		pAnsMax[params+1]=-DotProduct(pMean,pAnsMax,params);
		//printf("Max Eigen-Value: %g\n",dMax);
		//PrintVectorD(pAns,params+1,"Max Eigen-Vector");
	
		if(pChiSquare)
		{
			//Calculate the residual.
			dChiSquare = 0;
			for(i=1;i<=nRows;i++)
			{
				dResidual = 0;
				for(j=1;j<=params;j++)
				{
					dResidual += ppData[i][j]*pAnsMax[j];
				}
				dResidual += pAnsMax[params+1];
				dChiSquare += (dResidual*dResidual);
			}
			//printf("ChiSquare for MaxEig: %g\n",dChiSquare);
			pChiSquare[2] = dChiSquare;
		}

	}
	
	
	DeallocateVectorD(pMean,params);
	DeallocateMatrixD(ppMatrix,params,params);
	DeallocateVectorD(pV1,params);
	DeallocateVectorD(pV2,params);
}

//Fits a Plane to the given n-D data and returns the n-Orthogonal Vectors.
//The solution is calculated using eigen-vector fit method.
//ppData:				input X,Y,Z matrix.
//nRows:				number of rows.
//nCols:				number of columns.
//ppEigenVectors		An nxn Matrix, to be filled with calculated orthogonal vectors.
//						The vectors are returned in the descending order of eigenValues.
//						In case of Plane, the first vector corresponds to plane normal (Direction of min Variance)
//pEigenValues			Corresponding eigenValues.
//
int 
FindOrthogonalVectors(double** ppData,int nRows,int nCols,double** ppEigenVectors,double* pEigenValues)
{
	int params = nCols;
	int i,j,k;
	double** ppMatrix = AllocateMatrixD(params,params);
	double* pMean = AllocateVectorD(params);
	double *pV1 = AllocateVectorD(params);
	double *pV2 = AllocateVectorD(params);
	double *pTemp;

	ZeroMatrixD(ppMatrix,params,params);
	ZeroVectorD(pMean,params);
		
	//Calculate mean for each column.
	for(i=1;i<=nRows ; i++)
	{
		pTemp =ppData[i];
		for(j=1;j <=params;j++)
		{
			pMean[j] += pTemp[j];
		}
	}
	
	for(j=1;j<=params;j++)
	{
		pMean[j]/=(double)nRows;
	}
		
	//Calculate covariance matrix.
	for(j=1;j<=params;j++)
	{
		for(k=1;k<=params;k++)
		{
			for(i=1;i<=nRows;i++)
			{
				ppMatrix[j][k] += ((ppData[i][j]-pMean[j])*(ppData[i][k]-pMean[k]));
			}
		}
	}
		
	//Get eigen-values and eigen-vectors.
	tred2(ppMatrix,params,pV1,pV2);
	tqli(pV1,pV2,params,ppMatrix);
	
	//Sort the EignenVectors. Note that the sorting is descending order. Max comes first.
	eigsrt(pV1,ppMatrix,params);

	//Copy the answer.
	for(i=1;i<=params;i++)
	{
		pEigenValues[i] = pV1[i];
		
		for(j=1;j<=params;j++)
		{
			ppEigenVectors[j][i] = ppMatrix[j][i];
		}
	}
	
	DeallocateVectorD(pMean,params);
	DeallocateMatrixD(ppMatrix,params,params);
	DeallocateVectorD(pV1,params);
	DeallocateVectorD(pV2,params);
}	
		
//Performs Principal component analysis of given nD data. The caculated components are returned in descending order.
//The solution is calculated using eigen-vector fit method.
//ppData:				input X,Y,Z matrix.
//nRows:				number of rows.
//nCols:				number of columns.
//ppProjectedData		ppData projected to calculated orthogonal axes. The maximum component is in first column.
int 
PerformPCA(double** ppData,int nRows,int nCols,double** ppProjectedData)
{
	int params = nCols;
	int i,j,k;
	double** ppMatrix = AllocateMatrixD(params,params);
	double* pMean = AllocateVectorD(params);
	double *pV1 = AllocateVectorD(params);
	double *pV2 = AllocateVectorD(params);
	double *pTemp;

	ZeroMatrixD(ppMatrix,params,params);
	ZeroVectorD(pMean,params);
		
	//Calculate mean for each column.
	for(i=1;i<=nRows ; i++)
	{
		pTemp =ppData[i];
		for(j=1;j <=params;j++)
		{
			pMean[j] += pTemp[j];
		}
	}
	
	for(j=1;j<=params;j++)
	{
		pMean[j]/=(double)nRows;
	}
		
	//Calculate covariance matrix.
	for(j=1;j<=params;j++)
	{
		for(k=1;k<=params;k++)
		{
			for(i=1;i<=nRows;i++)
			{
				ppMatrix[j][k] += ((ppData[i][j]-pMean[j])*(ppData[i][k]-pMean[k]));
			}
		}
	}
		
	//Get eigen-values and eigen-vectors.
	tred2(ppMatrix,params,pV1,pV2);
	tqli(pV1,pV2,params,ppMatrix);
	
	//Sort the EignenVectors. Note that the sorting is descending order. Max comes first.
	eigsrt(pV1,ppMatrix,params);

	//Project the data to calculated eigenVectors..
	for(i=1;i<=nRows;i++)
	{
		for(j=1;j<=nCols;j++)
		{
			ppProjectedData[i][j] = 0;
			for(k=1;k<=params;k++)
			{
				ppProjectedData[i][j] += (ppMatrix[k][j]*(ppData[i][k]-pMean[k]));
			}
		}
	}
	
	DeallocateVectorD(pMean,params);
	DeallocateMatrixD(ppMatrix,params,params);
	DeallocateVectorD(pV1,params);
	DeallocateVectorD(pV2,params);
}	

/*Calculates the rank of the given NR matrix using svd. If tol is
zero it is taken as max(rows*cols)*max_svd*eps. Rank equals the number
of svd's higher than this tol.
*/
int GetRank(double** a,int rows,int cols,double tol)
{
	double **m, *w, **v;
	m = AllocateMatrixD(rows,cols);
	v = AllocateMatrixD(cols,cols);
	w = AllocateVectorD(cols);
	
	for(int i=1;i<=rows;i++)
		for(int j=1;j<=cols;j++)
			m[i][j] = a[i][j];
	
	Svdcmp(m,rows,cols,w,v);
	
	if(tol==0)
	{
		tol = w[1]*MAX(rows,cols)*1e-12;
	}
	int rank = 0;
	
	for(int i=1;i<=cols;i++)
	{
		if(fabs(w[i])>tol)
			rank++;
	}
	
	//free resources.
	DeallocateMatrixD(m,rows,cols);	
	DeallocateMatrixD(v,cols,cols);
	DeallocateVectorD(w,cols);
	
	//return with result.
	return rank;
}

double Determinant2(double** m)
{
	return m[1][1]*m[2][2] - m[2][1]*m[1][2];
}

double** SubMatrix2(double** m,int row1,int row2,int col1,int col2)
{
	double** mat = AllocateMatrixD(2,2);
	mat[1][1] = m[row1][col1];
	mat[1][2] = m[row2][col2];
	mat[2][1] = m[row2][col1];
	mat[2][2] = m[row2][col2];
	
	return mat;
}

double** SubMatrix3(double** m,int row1,int row2,int row3,int col1,int col2,int col3)
{
	double** mat = AllocateMatrixD(3,3);
	
	mat[1][1] = m[row1][col1];
	mat[1][2] = m[row1][col2];
	mat[1][3] = m[row1][col3];
	
	mat[2][1] = m[row2][col1];
	mat[2][2] = m[row2][col2];
	mat[2][3] = m[row2][col3];
	
	mat[3][1] = m[row3][col1];
	mat[3][2] = m[row3][col2];
	mat[3][3] = m[row3][col3];
	
	return mat;
}

double Determinant3(double** m)
{
	double ** a11 = SubMatrix2(m,2,3,2,3);
	double ** a12 = SubMatrix2(m,2,3,1,3);
	double ** a13 = SubMatrix2(m,2,3,1,2);
	
	double ans = m[1][1]*Determinant2(a11) - m[1][2]*Determinant2(a12) + m[1][3]*Determinant2(a13);
	
	DeallocateMatrixD(a11,2,2);
	DeallocateMatrixD(a12,2,2);
	DeallocateMatrixD(a13,2,2);
	
	return ans;
}

double Determinant4(double** m)
{
	double** a11 = SubMatrix3(m,2,3,4,2,3,4);
	double** a12 = SubMatrix3(m,2,3,4,1,3,4);
	double** a13 = SubMatrix3(m,2,3,4,1,2,4);
	double** a14 = SubMatrix3(m,2,3,4,1,2,3);
	
	double ans = m[1][1]*Determinant3(a11) - m[1][2]*Determinant3(a12) 
			   + m[1][3]*Determinant3(a13) + m[1][4]*Determinant3(a14);
			   
	DeallocateMatrixD(a11,3,3);
	DeallocateMatrixD(a12,3,3);
	DeallocateMatrixD(a13,3,3);
	DeallocateMatrixD(a14,3,3);
	
	return ans;
}
/*Calculates inverse of matrix using gauss-jordan pivoting.
Checks the rank, if its not ok, then fails.
*/
int GetInv(double** a,double** a_inv,int rows,int cols)
{
	double **b;
	
	if(rows!=cols)
	{
		fprintf(stderr,"GetInv: matrix is not square\n");
		return 0;
	}
	
	if(GetRank(a,rows,cols)<MIN(rows,cols))
	{
		fprintf(stderr,"GetInv: matrix singular cannot invert\n");
		return 1;
	}
	
	b = AllocateMatrixD(rows,1);
	
	for(int i=1;i<=rows;i++)
		for(int j=1;j<=cols;j++)
			a_inv[i][j] = a[i][j];
	
	gaussj(a_inv,rows,b,1);
	
	//free resources.
	DeallocateMatrixD(b,rows,1);
	
	//return with result.
	return 0;
}

/* Find the roots of poly-nomial.
*/
int FindPolyRoots(double* polynomial,int degree, double* realRoot,double* complexRoot)
{
	zrhqr(polynomial,degree,realRoot,complexRoot);
	return 0;
}


/* Finds the eigen values and eigen vectors of a given matrix 
	Must be square paramsXparams
*/
int FindEig(double** ppData,int params,double** ppEigVectors, double* pEigenValues)
{
	int i,j,k;
	double *pV1 = pEigenValues;
	double *pV2 = AllocateVectorD(params);
	
	//Copy input matrix to ppEigVectors.
	CopyMatrixD(ppData,params,params,ppEigVectors);
			
	//Get eigen-values and eigen-vectors.
	tred2(ppEigVectors,params,pV1,pV2);
	tqli(pV1,pV2,params,ppEigVectors);

	DeallocateVectorD(pV2,params);
}
		

#undef NRANSI
